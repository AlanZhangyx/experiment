* 哈希算法，是一类**算法**；

* 哈希表（Hash Table）是一种**数据结构**；

* 哈希函数，是**支撑哈希表**的一类函数；

* **`Map`**是映射、地图的意思，在Java中`Map`表示一种把`K`映射到`V`的数据结构；

* **`HashMap`**是Java中用哈希算法实现的`Map`；

******************************************
******************************************
******************************************

# 一、Hash算法

##1. 是什么？ 
1. 释义
    先来看英语翻译：
    ```
    hash
        英 [hæʃ]   美 [hæʃ]
    n. 剁碎的食物；混杂，拼凑；重新表述
    vt. 搞糟，把…弄乱；切碎；推敲
    n. (Hash)人名；(阿拉伯、保、英)哈什；(西)阿什
    ```
    我觉得 **切碎** 最适合，但正式上会被称为“***散列** *”。有时候也叫“***哈希** *”，据说是因为最早翻译的人以为这是某个叫*Hash *的人发明的算法，所以音译了其名字；
 
    *（下面我可能会根据情况混合使用这些词，所以要记得他们是**同义词**）*
 
2. 所以
    ***Hash算法 ***是这样一类算法：
    >这类算法接受**任意长度的二进制输入值**，对输入值做换算（切碎），最终给出**固定长度的二进制输出值**；
    
    所以注意：*Hash算法 *不是某个固定的算法，它代表的是**一类算法**。
    
    以更好理解的方式来说，Hash算法是**摘要算法 **：也就是说，从不同的输入中，通过一些计算摘取出来一段输出数据，值可以用以**区分输入数据**。
    
    所以，***MD5 ***可能是最著名的一种*Hash算法 *了。
    ![这里写图片描述](http://img.blog.csdn.net/20160725232902415)

##2. 有什么用？


那么，具体来说***Hash/摘要/散列/切碎算法 ***有哪些用处呢？

1. **信息安全领域**：

  *Hash算法 *可用作**加密算法**。
  如**文件校验**：通过对文件摘要，可以得到文件的“数字指纹”，你下载的任何副本的“数字指纹”只要和官方给出的“数字指纹”一致，那么就可以知道这是未经篡改的。例如著名的*MD5 *；
2. **数据结构领域**：

  *Hash算法 *通常还可用作**快速查找**。
  这是今天我想说的部分。根据*Hash函数 *我们可以实现一种叫做***哈希表（Hash Table）***的数据结构。这种结构可以实现对数据进行快速的存取。

****************************
接下来我们就来看看这次最关心的*Hash函数 *的一个应用领域：数据结构 - 哈希表；
************************************
************************************
************************************

#二、哈希表

##1. 什么是哈希表
首先想一个问题：我们是如何在数据结构中做查找的呢？

* **线性表、树**

    *线性表、树 *这些结构中，*记录 *在*结构 *中的相对位置是随机的，和记录的关键字之间不存在确定关系，因此，在结构中查找时需要进行一系列和关键字的比较。这一类查找方法建立在**“比较”**的基础上。在顺序查找时，比较的结果为“=”与“≠”2种可能；在折半查找、二叉排序树查找和B-树查找时，比较的结果为“<”“=”“>”3种可能。查找的效率依赖于查找过程中所进行的比较次数。
    
* **哈希表**
    
    理想的情况是希望不经过任何比较，一次存取便能得到所查记录，那就必须在**记录的存储位置**和它的**关键字**之间建立一个确定的关系$f$，使每个关键字和结构中一个唯一的存储位置相对应。因而在查找时，只要根据这个对应关系$f$找到给定值$K$的像$f(K)$。若结构中存在关键字和$K$相等的记录，则必定在$f(K)$的存储位置上，反之在这个位置上没有记录。由此，不需要比较便可直接取得所查记录。在此，我们称这个对应关系$f$为***哈希(Hash)函数 ***，按这个思想建立的表为***哈希表 ***。

这是《数据结构（C语言版）》中引出哈希表的一段描述，通俗易懂。所以，我们知道了什么是***哈希函数 ***和***哈希表 ***。

* **哈希函数**

1. 灵活
    哈希函数是一个映像，因此哈希函数的设定很灵活，只要使得任何关键字由此所得的哈希函数值都落在表长允许的范围之内即可。

2. 冲突
    对不同的关键字可能得到同一哈希地址，即$ key1 ≠ key2 $，而$ f(key1)= f(key2)$ ，这种现象称为冲突（collision）；

        冲突只能尽量地少，而不能完全避免。因为，哈希函数是从关键字集合到地址集合的映像。而通常关键字集合比较大，它的元素包括所有可能的关键字，而地址集合的元素仅为哈希表中的地址值。因此，在实现哈希表这种数据结构的时候不仅要设定一个“好”的哈希函数，而且要设定一种处理冲突的方法。

综上所述，我们可以如下描述哈希表：
>根据设定的Hash函数$H(key)$和处理冲突的方法，将一组关键字***映象 ***到一个**有限的连续的地址集**（区间）上，并以关键字在地址集中的***象 ***作为记录在表中的**存储位置**，这样的表便称为***Hash表 ***；




2. **常用Hash函数**：

    实际工作中，需要视不同的情况采用不同的Hash函数，通常要考虑的因素有：

    * *Hash函数 *执行的时间；
    * *关键字 *的长度；
    * *Hash表 *的大小；
    * *关键字 *的分布情况；
    * *记录 *的查找频率；

    有如下一些常用的函数：
    （关键字为：*k *、*Hash表 *的表长为：*m *）
    
    1. 直接寻址法：

        $ f(k) = k$ 或者$ f(k) = a * k + b$

        取*k *或*k *的某个**线性函数 **为*Hash地址 *。若$f(k)$中已经有值了，就往下一个找，直到$f(k)$中没有值了就放进去。

    2. 数字分析法：

        首先分析待存的一组*关键字 *，比如是一个班级学生的*出生年月日 *，我们发现他们的出生*年 *大体相同，那么我们肯定不能用他们的*年 *来作为*存储地址 *，这样出现*冲突 *的几率很大；但是，我们发现*月日 *的具体数字差别很大，如果我们用*月日 *来作为*Hash地址 *，则会明显降低冲突几率。因此，数字分析法就是找出*关键字 *的规律，尽可能用差异数据来构造*Hash地址 *；

    3. 平方取中法：
        
        当无法确定关键字中哪几位分布较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为哈希地址。这是因为：平方后中间几位和关键字中每一位都相关，故不同关键字会以较高的概率产生不同的哈希地址。

        例：我们把英文字母在字母表中的位置序号作为该英文字母的内部编码。例如K的内部编码为11，E的内部编码为05，Y的内部编码为25，A的内部编码为01, B的内部编码为02。由此组成关键字“KEYA”的内部代码为11052501，同理我们可以得到关键字“KYAB”、“AKEY”、“BKEY”的内部编码。之后对关键字进行平方运算后，取出第7到第9位作为该关键字哈希地址，如下图所示：
        | 关键字 | 内部编码 | 内部编码的平方值 | H(k)关键字的哈希地址 |
        | ------------- |-------------|-------------|-------------|
        | KEYA | 11050201 | 122157778355001 | 778 |
        | KYAB | 11250102 | 126564795010404 | 795 |
        | AKEY | 01110525 | 001233265775625 | 265 |
        | BKEY | 02110525 | 004454315775625 | 315 |

        <sup>[1]</sup>

    4. 折叠法：

        将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。数位叠加可以有移位叠加和间界叠加两种方法。移位叠加是将分割后的每一部分的最低位对齐，然后相加；间界叠加是从一端向另一端沿分割界来回折叠，然后对齐相加。

    5. 随机数法：

        选择一随机函数，取关键字的随机值作为散列地址，通常用于关键字长度不同的场合。

    6. **除留取余法**：
        
        $ f(k) = k$  $mod$   $p$ ;  $p<=m$
        
        取关键字被某个数*p *除后所得的余数为*Hash地址 *。*p *最好选择不大于表长*m *的一个*质数 *。*p *选的不好会容易产生*同义词 *。这个是最常用的了。

3. **解决冲突**
    上面已经解释了冲突的产生，那么有哪些解决冲突的办法呢？

    基本上有以下4种方法：

    1. 开放寻址法：

    2. 再Hash法：
        
        即在同义词产生地址冲突时，加入另一个*Hash函数 *来计算地址，直到冲突不再发生，这种方法不易产生*聚集 *，但增加了计算时间；
        
    3. **链地址法**：
        
        在*Hash *出来的内存地址中不直接存*Key *，而是存储一个*Key *的*链表 *，当发生*冲突 *时，将*同义的Key *加入*链表 *；
        
        ![这里写图片描述](http://img.blog.csdn.net/20160724225743051)

        即：存放时首先使用*Hash函数 *计算*Key *的地址，之后再把*Value *和所得*链表 *中每个*结点 *比较，没有相等的则**追加存放**，如果有相等的则**覆盖存放**；

    4. 公共溢出区：

        可以建立一个公共溢出区，用来存放有冲突的*Key *。

************************************
好了，接下来我们来看一看*Java *中的`HashMap`是怎么实现的
************************************
************************************
************************************

#三、Java的HashMap

在Java中，`Primary`类型和`数组`是直接被`编译器`支持的数据结构，而`其它对象`包括`Java容器类`都是由Java官方或者你自己的`API`包装了一层的数据结构。

所以，在我们看源码之前，你首先得先明白，要实现这样一种数据结构，最终我们肯定得借助于其它数据结构，无论是API包装的，还是原生支持的。

那么好，我们来看*Java *中`容器类`中的一种： `HashMap`

1. `Map interface`

    首先来看`HashMap`的父接口`Map`，下图是其大纲：

    ![这里写图片描述](http://img.blog.csdn.net/20160724235723474)

***********************
参考文献：

[\[1\] 哈希表及处理冲突的方法．新浪微博．2011-10-10](http://blog.sina.com.cn/s/blog_6fd335bb0100v1ks.html)



##3. 基本理论
算法通常用函数的形式表现出来，所以我们来定义一下函数

1. 概念：

    *输入值 *叫做：*关键字 * - $ K $
    *换算过程 *叫做：*Hash函数 * - $ f()$ 
    *输出值 *叫做：*Hash值 * - $ f(K)$

2. 性质：

    所有*Hash函数 *都必须满足的基本特性是：

    同一Hash函数情况下
    * 两个Hash值**不同**，那么两个输入**一定不同**；
    * 两个Hash值**相同**，那么输入**不一定相同**；
    * 典型的*Hash函数 *有**无限的*定义域*（$Key$）**，如任意长度的字符串；**有限的*值域*（$f(Key)$）**，如固定长度的二进制串；

3. **冲突**：

    如上基本性质所述，定义域是无限的，而能够被映射的值域是有限的。所以一定会出现基本性质2：
    * **不同的$ K $**，却得到了**相同的$ f(K)$**的情况     
        即$ Key1 ≠ Key2 $，
        而$ f(Key1)= f(Key2)$ ；
           
        这种情况就叫做***Hash冲突 ***；所以，冲突是不可避免的。当然，有冲突就会有解决冲突的办法，这个之后再表；
    
    * **同义词**
        还有一个同义词的概念是说：具有相同*Hash值 *的**$ K $们**，对该*Hash函数 *来说称作***同义词 ***；



1. 定义
    
    如果我们将*Hash算法 *如下这样使用：

    >根据*Hash函数 *和*处理冲突 *的方法，将一组关键字***映象 ***到一个**有限的连续的地址集**（区间）上，并以关键字在地址集中的***象 ***作为记录在*表 *中的**存储位置**，这样的*表 *便称为***Hash表 ***。

    也就是说，通过***Hash函数 ***来得到**Key的存储位置**，从而实现**Value的直接存取**。这一过程称为*Hash造表 *，所得存储位置称为***Hash地址 ***。

    **请一定别混淆：**
    * ***Hash表 ***是一种**Key - Value 的表数据结构**；
    * ***Hash算法 ***可以用来计算*Hash表 *中某个*Key *对应的**Value的存储地址**；
    
    理解*Hash表 *有个非常好的例子是，想象一下*Hash表 *就是你的**手机通讯录**：
    * 通常*联系人(Value) *是以字母*A-Z *排序存储的，联系人排序后的位置是其存储地址*(Hash地址) *；
    * 当你要查找*“张三”*的号码时，你以*“Z”*做为关键字(*Key *)让通讯录软件*Hash *计算*Z *的存储地址，接着通讯录跳转到此地址显示给你看；
    * 但*Z *存储地址有不只一个联系人，还可能有*“郑六”*等（*Hash冲突 *），你需要在*Z *地址找到你真正要找的人 -*“张三”*（解决冲突）；